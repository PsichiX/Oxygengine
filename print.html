<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Oxygengine Essentials Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="cli/introduction.html"><strong aria-hidden="true">2.</strong> Oxygengine Ignite CLI tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/new-project.html"><strong aria-hidden="true">2.1.</strong> Creating new project</a></li><li class="chapter-item expanded "><a href="cli/build-project.html"><strong aria-hidden="true">2.2.</strong> Building your project</a></li><li class="chapter-item expanded "><a href="cli/update.html"><strong aria-hidden="true">2.3.</strong> Update engine version used in your game project</a></li><li class="chapter-item expanded "><a href="cli/faster-compilation-times.html"><strong aria-hidden="true">2.4.</strong> Speed up compilation times for new projects</a></li><li class="chapter-item expanded "><a href="cli/asset-pipeline.html"><strong aria-hidden="true">2.5.</strong> Asset pipeline and its tools</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Concepts explained</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/ha-renderer/introduction.html"><strong aria-hidden="true">3.1.</strong> Hardware Accelerated rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/ha-renderer/render-pipeline.html"><strong aria-hidden="true">3.1.1.</strong> Render Pipeline</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.2.</strong> Camera</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.3.</strong> Render Target</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.4.</strong> Image</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.5.</strong> Virtual Image</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.6.</strong> Mesh</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.7.</strong> Virtual Mesh</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.8.</strong> Material</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Tutorials</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> RPG game using Overworld module</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> VN game using Visual Novel module</div></li></ol></li><li class="chapter-item expanded "><a href="more.html"><strong aria-hidden="true">5.</strong> More...</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Oxygengine Essentials Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In this book we will cover all essential information regarding usage of Oxygengine.
That being said, we should explain first what Oxygengine is, what it aims to be
and what's definitely not made for.</p>
<h2 id="the-goal"><a class="header" href="#the-goal">The goal</a></h2>
<p>Oxygengine is an all-batteries-included kind of engine, focused on being Web-first.
The <strong>goal</strong> is for it to be a Rust version of Unreal Engine for 2D games, which
made us take a very important decision from the beggining, for it being a completely
asset-driven game engine with game editor dedicated mostly for <strong>Game Designers</strong>
to use. That means, all architecture decisions are made to ease interacting with
all parts of the engine from game editor with next to none use of code.</p>
<p>This also means that while Oxygengine is a general purpose 2D game engine, it aims
to provide specialized modules to ease work on specific game genres. At the moment
we already have specialized game modules for these kind of games:</p>
<ul>
<li><a href="https://github.com/PsichiX/Oxygengine/tree/master/engine/visual-novel">Visual Novel</a></li>
<li><a href="https://github.com/PsichiX/Oxygengine/tree/master/engine/overworld">Role-Playing Game</a></li>
</ul>
<h2 id="where-we-are-now"><a class="header" href="#where-we-are-now">Where we are now</a></h2>
<p>At this point Oxygengine is near its stable version from the code architecture
point of view, but <strong>does not have</strong> a game editor ready to use yet, although
editor is still work in progress and it might be released in 2022, not yet decided
on any particular month.</p>
<h2 id="where-could-i-use-oxygengine"><a class="header" href="#where-could-i-use-oxygengine">Where could i use Oxygengine</a></h2>
<p>Since this engine is Web-first and 2D-focused and it aims to give you a specific
games genre solutions to let you just make a game, you most likely would want to
use it if you aim for making one of these kind of games:</p>
<ul>
<li>Visual Novels</li>
<li>RPGs</li>
</ul>
<p>Genres we will cover soon in new specialized engine modules:</p>
<ul>
<li>Platformers</li>
<li>Shooters</li>
</ul>
<p>Every other genres, although they are possible to make, we do not provide or
rather not yet plan to provide a specialized engine module.</p>
<h2 id="where-i-cant-use-oxygengine"><a class="header" href="#where-i-cant-use-oxygengine">Where i can't use Oxygengine</a></h2>
<p>This engine is basically useless (yet) for any kind of 3D game (maybe except
original Doom-like games, but these would require heavy hammering).
Also definitely do not use it (yet) to make desktop or gaming console titles
(but there are plans for desktop/steam platforms and if we get lucky to sign a
partnership with gaming console producents, we might provide a private dedicated
engine modules).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oxygengine-ignite-cli-tool"><a class="header" href="#oxygengine-ignite-cli-tool">Oxygengine Ignite CLI tool</a></h1>
<p>Although Oxygengine can be used like any other crate, it's better to install
Ignite CLI tool that will govern most vital operations on your game project
development:</p>
<pre><code class="language-bash">cargo install oxygengine-ignite
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-new-project"><a class="header" href="#creating-new-project">Creating new project</a></h1>
<p>Oxygengine uses a concept called &quot;Game Templates&quot; where instead of starting from
blank page, you create your new project from one of existing game templates:</p>
<ul>
<li><code>desktop-headless-game</code> - used mostly for game servers logic, it doesn not
provide access to any of rendering or audio features, but gives you all the
features needed to create a game server logic.</li>
<li><code>web-composite-game</code> - used for making visually simple games that uses Web
Canvas rendering.</li>
<li><code>web-composite-visual-novel</code> - used to jumpstart working on a completely
asset-driven Visual Novel game.</li>
<li><code>web-ha-game</code> - used to make visually more demanding games that needs to render
greater number of entities, manipulate and enhance game visuals with shaders.</li>
</ul>
<p><strong>Create new game project with default (<code>web-ha-game</code>) game template:</strong></p>
<pre><code class="language-bash">oxygengine-ignite new &lt;project-name&gt;
</code></pre>
<p>for example:</p>
<pre><code class="language-bash">oxygengine-ignite new dream-game
</code></pre>
<p><strong>Create new game with specified game template to use:</strong></p>
<pre><code class="language-bash">oxygengine-ignite new &lt;project-name&gt; -p &lt;game-template-name&gt;
</code></pre>
<p>for example:</p>
<pre><code class="language-bash">oxygengine-ignite new dream-game-server -p desktop-headless-game
</code></pre>
<p><strong>Create new game project in specified path:</strong></p>
<pre><code class="language-bash">oxygengine-ignite new &lt;project-name&gt; -d &lt;path-to-parent-directory&gt;
</code></pre>
<p>for example:</p>
<pre><code class="language-bash">oxygengine-ignite new dream-game -d ~/game-projects/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-project"><a class="header" href="#building-your-project">Building your project</a></h1>
<h3 id="launch-live-development"><a class="header" href="#launch-live-development">Launch live development</a></h3>
<p>With active code recompilation and assets baking in the background on change:</p>
<pre><code class="language-bash">oxygengine-ignite live
</code></pre>
<p>Additionally to allow it to start http server to serve your build files in the
browser, run:</p>
<pre><code class="language-bash">oxygengine-ignite live -- -p 8080
</code></pre>
<p>files will be served from: http://localhost:8080.</p>
<h3 id="build-binaries-in-debug-or-release-mode"><a class="header" href="#build-binaries-in-debug-or-release-mode">Build binaries in debug or release mode</a></h3>
<p>Binaries will be put in <code>/bin</code> folder.</p>
<p>With debug symbols:</p>
<pre><code class="language-bash">oxygengine-ignite build
</code></pre>
<p>Optimized release mode:</p>
<pre><code class="language-bash">oxygengine-ignite build -p release
</code></pre>
<h3 id="build-only-the-crate"><a class="header" href="#build-only-the-crate">Build only the crate</a></h3>
<pre><code class="language-bash">cargo build
</code></pre>
<h3 id="package-application-build-with-assets-ready-for-distribution"><a class="header" href="#package-application-build-with-assets-ready-for-distribution">Package application build with assets ready for distribution</a></h3>
<p>Package files will be put in <code>/dist</code> folder:</p>
<pre><code class="language-bash">oxygengine-ignite package
</code></pre>
<p>this command will run release build, assets pipeline and bundle package.</p>
<p>To produce a debug mode package you have to run:</p>
<pre><code class="language-bash">oxygengine-ignite package -d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-engine-version-used-in-your-game-project"><a class="header" href="#update-engine-version-used-in-your-game-project">Update engine version used in your game project</a></h1>
<ul>
<li>reinstall <code>oxygengine-ignite</code>:
<pre><code class="language-bash">cargo install oxygengine-ignite --forced
OXY_UPDATE_PRESETS=1 oxygengine-ignite --help
</code></pre>
</li>
<li>update <code>oxygengine</code> version either in <code>Cargo.toml</code> or by calling: <code>cargo update</code></li>
<li>upgrading from versions before 0.12.0 requires to create new project with
latest ignite tool, then copy by hand your source files to the new project
sources, as well as put assets from old project <code>/static/assets</code> directory
into new project <code>/assets</code> directory, preferably using new way of assets
directory structure (so you won't have to modify <code>pipeline.json</code> file to much).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="speed-up-compilation-times-for-new-projects"><a class="header" href="#speed-up-compilation-times-for-new-projects">Speed up compilation times for new projects</a></h1>
<p>Best use case for gamejams and quick feature prototypes.</p>
<ul>
<li>install SCCACHE, a tool for caching and sharing prebuilt dependencies between
multiple game projects (https://github.com/mozilla/sccache):
<pre><code class="language-bash">cargo install sccache
</code></pre>
</li>
<li>add these lines to the <code>Cargo.toml</code>:
<pre><code class="language-toml">[package.metadata]
# path to the sccache binary
sccache_bin = &quot;sccache.exe&quot;
# path to the sccache cache directory
sccache_dir = &quot;D:\\sccache&quot;
</code></pre>
</li>
</ul>
<p>From now on you will have to wait for full long engine build only once, for any
other new game project you create, it will perform first compilation in matter
of minute, not 20.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-pipeline-and-its-tools"><a class="header" href="#asset-pipeline-and-its-tools">Asset pipeline and its tools</a></h1>
<p>Since Oxygengine is highly data-driven, we put most if not all data into assets,
that's where the idea of asset pipeline was born. Asset pipeline is used to take
source files such as images, levels, sounds, basically every file that contains
some static and read-only data your game wants to use, and it converts it to data
format that suits best engine internals needs.</p>
<p>For example you can have many different source image to be rendered but all engine
cares about is the image data and not its source format, so we use asset pipeline
tools to convert them into engine's internal image format, or to even compress
them. Actually, better example can be found with fonts or levels.</p>
<p>In HA (hardware-accelerated) renderer we use SDF-compatible font map images so we
obviously need to bake them either from BMfont generated files or other font
rasterization software. For game levels we use free LDtk level editor so we have
a LDtk asset pipeline tool that takes LDtk project files and bakes images from
tilesets, prefabs with entities from level layers and additional data assets from
used grid layer values.</p>
<p>Asset pipelien tools are just CLI binaries that uses <code>oxygengine-build-tools</code>
crate types to read input data passed to your tool, and your tool job is to write
new files to given path. That means, if you need to have support for custom/additional
asset sources, you can easily make an asset pipeline tool for it.</p>
<p><strong>IMPORTANT:</strong>
When using either HA renderer or composite renderer, you have to also install
their asset pipeline tools for asset pipeline to be able to bake assets.
These are:</p>
<ul>
<li><code>cargo install oxygengine-composite-renderer-tools</code></li>
<li><code>cargo install oxygengine-ha-renderer-tools</code></li>
</ul>
<p>In general, if some engine module requires asset pipeline tools to work, there
is a companion crate named: <code>&lt;some-engine-module&gt;-tools</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-accelerated-rendering"><a class="header" href="#hardware-accelerated-rendering">Hardware Accelerated rendering</a></h1>
<p>Here we will take a deeper look at how Oxygengine's hardware Accelerated
rendering model works.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>HA renderer uses completely data-driven, material-graph based rendering approach.
The most important unit in HA renderer is Render Pipeline.</p>
<ul>
<li>Render Pipelines are containers for Render Targets and Render Stages.</li>
<li>Render Targets are a GPU storage, more precisely dynamic textures that all
rendered information gets stored into.</li>
<li>Render Stages are containers for Render Queues and are used by dedicated render
systems which define how entities (or any custom data in mater of fact) gets
rendered into Render Target that Render Stage points to.</li>
<li>Render systems work on cameras and record Render Commands into Render Queue
assigned to given Render Stage.</li>
<li>Render Stage also defines Material Domain (which is basically a shader backend)
that will be linked with Material Graphs (which are shader frontends) of
entities that gets rendered (more about how Materials works later on this page).</li>
</ul>
<h2 id="material-graph-based-rendering"><a class="header" href="#material-graph-based-rendering">Material-graph based rendering</a></h2>
<p>While most game engines expose raw shaders to the users to make them tell exactly
how anything should be rendered, Oxygengine took another path and do not expose
any shader code, these are considered engine internals that user should never be
forced to write on their own. More than that, shaders gets baked at runtime (or
build-time, both material graphs and baked materials are assets) only when engine
finds that certain pair of material domain (backend) and material graph (frontend)
are gonna be used in rendering.</p>
<p>Material domain and material graphs always work in tandem, material domain job is
to preprocess vertex and uniform data and send it to material graph (via specific
interface that given domain defines) for it to post process that data and send it
back for material domain to store it properly in target outputs.</p>
<p>The reason for them being separate units is because HA renderer aims for in case
of user wanting to do some different visuals than default ones provided by the
engine, to focus only on the effect and don't bother writing additional logic just
to meet specialized vertex format and render target requirements. Another benefit
we get from this approach is that now user can make his frontend material once and
renderer will bake at runtime all variants needed all pairs of domain and graph
materials. This basically means that user can now get his material graph working
without any additional work with any vertex format and target format that renderer
find compatible at runtime. In even simpler words: imagine you have a material
graph that has to add outlines to the image, in that case no matter if you render
your entity for example in forward or deferred renderer, it will work for both by
default as long as both use material domains which provide domain node that your
outline material uses.</p>
<p><strong>IMPORTANT:</strong> all shader variants for given material are considered unique as
long as they have different Material Signatures:</p>
<ul>
<li>Material Signature is defined by Material Mesh Signature + Material Render
Target Signature + Domain name + Vertex Middlewares used</li>
<li>Material Mesh Signature is defined by unique Vertex Layout (vertex layouts are
defined by meshes, to be more precise by the vertex format given mesh data uses)</li>
<li>Material Render Target Signature is defined by set of render target output
names.</li>
</ul>
<h2 id="1-picture-say-more-than-1000-words"><a class="header" href="#1-picture-say-more-than-1000-words">1 picture say more than 1000 words</a></h2>
<p>Let's take a look at the simplest material domain (this is code-side
representation of the material domain/graph):</p>
<pre><code class="language-rust ignore">material_graph! {
    inputs {
        [fragment] inout BaseColor: vec4 = {vec4(1.0, 1.0, 1.0, 1.0)};

        [vertex] uniform model: mat4;
        [vertex] uniform view: mat4;
        [vertex] uniform projection: mat4;

        [vertex] in position: vec3 = vec3(0.0, 0.0, 0.0);
        [vertex] in color: vec4 = vec4(1.0, 1.0, 1.0, 1.0);
    }

    outputs {
        [vertex] inout TintColor: vec4;
        [vertex] inout ScreenPosition: vec4;

        [vertex] builtin gl_Position: vec4;
        [fragment] out finalColor: vec4;
    }

    [model_view_projection = (mul_mat4,
      a: projection,
      b: (mul_mat4,
        a: view,
        b: model
      )
    )]
    [pos = (append_vec4, a: position, b: {1.0})]
    [screen_position = (mul_mat4_vec4, a: model_view_projection, b: pos)]

    [color -&gt; TintColor]
    [screen_position -&gt; ScreenPosition]
    [screen_position -&gt; gl_Position]
    [BaseColor -&gt; finalColor]
}
</code></pre>
<p>In this snippet we can see that this particular material domain expects model +
view + projection uniforms, as well as position + color vertex inputs, and it
writes data to gl_Position vertex output and finalColor target output. This
basically means that this material domain will work with stage that writes to
finalColor target output and position + color vertex format. It also will bake
shader variants for any material graph that <strong>might read</strong> TintColor and/or
ScreenPosition domain input, and <strong>might write</strong> BaseColor domain output.</p>
<p>Consider domain input/outputs to be purely an optional interface between material
domain and material graph. You might ask now: &quot;why domain interface is
optional?&quot; - well, this is where this approach shines: you see, when material
domain gets combined with material graph, it will bake shader only from nodes
that leads directly from target outputs to vertex inputs, with all required
nodes along the way, every nod not used in that path won't get compiled into GLSL
shader variant.</p>
<p>Now let's take a look at the simplest material graph:</p>
<pre><code class="language-rust ignore">material_graph! {
    inputs {
        [vertex] input TintColor: vec4 = {vec4(1.0, 1.0, 1.0, 1.0)};
    }

    outputs {
        [fragment] input BaseColor: vec4;
    }

    [[TintColor =&gt; vColor] -&gt; BaseColor]
}
</code></pre>
<p>Here in this material graph we can see we only use domain interface and just move
input color from vertex shader stage to fragment shader stage and send it back to
material domain to let it store properly for its render target outputs - when user
is making material graph, he doesn't have to care about how to write to targets,
he can only care how to process domain inputs into domain outputs and domain takes
care of properly storing data into target outputs.</p>
<p>Now imagine user wants to create material graph that do not use TintColor at all,
rather converts ScreenPosition into BaseColor:</p>
<pre><code class="language-rust ignore">material_graph! {
    inputs {
        [vertex] input ScreenPosition: vec4 = {vec4(0.0, 0.0, 0.0, 0.0)};
    }

    outputs {
        [fragment] input BaseColor: vec4;
    }

    [[ScreenPosition =&gt; vColor] -&gt; BaseColor]
}
</code></pre>
<p>This material graph when combined with our previously defined material domain,
will bake shader with nodes that only use screen position calculated in domain
graph and not include color vertex data in the shader at all since this shader
variant does not use it. Now, do you also see the benefits of this over usual
<code>#ifdef</code>-ed raw shaders?</p>
<h2 id="material-middlewares"><a class="header" href="#material-middlewares">Material middlewares</a></h2>
<p>Another concept used with material graphs is material middlewares - an ergonomic
way to &quot;inject&quot; other material graphs as material input preprocessor.</p>
<p>Consider you have a vertex format such as:</p>
<pre><code class="language-rust ignore">vertex_type! {
    #[derive(Debug, Default, Copy, Clone, Serialize, Deserialize)]
    @tags(SurfaceDomain, SurfaceTexturedDomain)
    pub struct SurfaceVertexPT {
        #[serde(default = &quot;default_position&quot;)]
        pub position: vec3 = position(0, bounds),
        #[serde(default = &quot;default_texture_coord&quot;)]
        pub texture_coord: vec3 = textureCoord(0),
    }
}
</code></pre>
<p>It is used to render for example regular entity sprites. Now you want to make
these sprites animated with skinning. Normally you would need to duplicate all
material domains that has to work with skinning which makes future changes and
general material maintanance subjective to being out of sync for starters - we
can avoid that problem entirely using material middlewares!</p>
<p>You start with defining skinned vertex format with skinning data only:</p>
<pre><code class="language-rust ignore">vertex_type! {
    #[derive(Debug, Default, Copy, Clone, Serialize, Deserialize)]
    @middlewares(skinning)
    pub struct SurfaceSkinningFragment {
        #[serde(default = &quot;default_bone_indices&quot;)]
        pub bone_indices: int = boneIndices(0),
        #[serde(default = &quot;default_bone_weights&quot;)]
        pub bone_weights: vec4 = boneWeights(0),
    }
}
</code></pre>
<p>As you can see, we have marked this vertex format to use skinning middleware.
We also define compound vertex format that will make that sprite vertex format
mixed with skinned vertex format:</p>
<pre><code class="language-rust ignore">compound_vertex_type! {
    #[derive(Debug, Default, Copy, Clone, Serialize, Deserialize)]
    @tags(SurfaceDomain, SurfaceSkinnedDomain, SurfaceTexturedDomain)
    pub struct SurfaceVertexSPT {
        #[serde(default)]
        pub vertex: SurfaceVertexPT,
        #[serde(default)]
        pub skinning: SurfaceSkinningFragment,
    }
}
</code></pre>
<p>Now we have to add skinning middleware material graph to Material Library resource:</p>
<pre><code class="language-rust ignore"><span class="boring">library.add_function(graph_material_function! {
</span><span class="boring">   fn skinning_fetch_bone_matrix(texture: sampler2D, index: int) -&gt; mat4 {
</span><span class="boring">       [return (make_mat4,
</span><span class="boring">           a: (texelFetch2d, sampler: texture, coord: (make_ivec2, x: {0}, y: index), lod: {0}),
</span><span class="boring">           b: (texelFetch2d, sampler: texture, coord: (make_ivec2, x: {1}, y: index), lod: {0}),
</span><span class="boring">           c: (texelFetch2d, sampler: texture, coord: (make_ivec2, x: {2}, y: index), lod: {0}),
</span><span class="boring">           d: (texelFetch2d, sampler: texture, coord: (make_ivec2, x: {3}, y: index), lod: {0})
</span><span class="boring">       )]
</span><span class="boring">   }
</span><span class="boring">});
</span><span class="boring">library.add_function(graph_material_function! {
</span><span class="boring">   fn skinning_weight_position(bone_matrix: mat4, position: vec4, weight: float) -&gt; vec4 {
</span><span class="boring">       [return (mul_mat4_vec4,
</span><span class="boring">           a: bone_matrix,
</span><span class="boring">           b: (mul_vec4, a: position, b: (fill_vec4, v: weight))
</span><span class="boring">       )]
</span><span class="boring">   }
</span><span class="boring">});
</span>library.add_middleware(
    &quot;skinning&quot;.to_owned(),
    material_graph! {
        inputs {
            [vertex] in position as in_position: vec3 = {vec3(0.0, 0.0, 0.0)};
            [vertex] in boneIndices: int = {0};
            [vertex] in boneWeights: vec4 = {vec4(0.0, 0.0, 0.0, 0.0)};

            [vertex] uniform boneMatrices: sampler2D;
        }

        outputs {
            [vertex] out position as out_position: vec3;
        }
<span class="boring">
</span><span class="boring">       [pos = (append_vec4, a: in_position, b: {1.0})]
</span><span class="boring">       [index_a = (bitwise_and, a: boneIndices, b: {0xFF})]
</span><span class="boring">       [index_b = (bitwise_and, a: (bitwise_shift_right, v: boneIndices, bits: {8}), b: {0xFF})]
</span><span class="boring">       [index_c = (bitwise_and, a: (bitwise_shift_right, v: boneIndices, bits: {16}), b: {0xFF})]
</span><span class="boring">       [index_d = (bitwise_and, a: (bitwise_shift_right, v: boneIndices, bits: {24}), b: {0xFF})]
</span><span class="boring">       [result = (skinning_weight_position,
</span><span class="boring">           bone_matrix: (skinning_fetch_bone_matrix, texture: boneMatrices, index: index_a),
</span><span class="boring">           position: pos,
</span><span class="boring">           weight: (maskX_vec4, v: boneWeights)
</span><span class="boring">       )]
</span><span class="boring">       [weighted = (skinning_weight_position,
</span><span class="boring">           bone_matrix: (skinning_fetch_bone_matrix, texture: boneMatrices, index: index_b),
</span><span class="boring">           position: pos,
</span><span class="boring">           weight: (maskY_vec4, v: boneWeights)
</span><span class="boring">       )]
</span><span class="boring">       [result := (add_vec4, a: result, b: weighted)]
</span><span class="boring">       [weighted := (skinning_weight_position,
</span><span class="boring">           bone_matrix: (skinning_fetch_bone_matrix, texture: boneMatrices, index: index_c),
</span><span class="boring">           position: pos,
</span><span class="boring">           weight: (maskZ_vec4, v: boneWeights)
</span><span class="boring">       )]
</span><span class="boring">       [result := (add_vec4, a: result, b: weighted)]
</span><span class="boring">       [weighted := (skinning_weight_position,
</span><span class="boring">           bone_matrix: (skinning_fetch_bone_matrix, texture: boneMatrices, index: index_d),
</span><span class="boring">           position: pos,
</span><span class="boring">           weight: (maskW_vec4, v: boneWeights)
</span><span class="boring">       )]
</span><span class="boring">       [result := (add_vec4, a: result, b: weighted)]
</span><span class="boring">       [(truncate_vec4, v: result) -&gt; out_position]
</span>    },
);
</code></pre>
<p>What is important there, material middlewares has to define in and out pins that
it injects in between, so in case of skinning we essentially tell material
compiler we want to inject skinning before vertex position data gets passed to
actual material - we are making skinning middleware as vertex input preprocessor:</p>
<pre><code class="language-rust ignore">inputs {
  [vertex] in position as in_position: vec3 = {vec3(0.0, 0.0, 0.0)};
}
outputs {
  [vertex] out position as out_position: vec3;
}
</code></pre>
<p>Now whenever we want to render mesh with <code>SurfaceVertexSPT</code> vertex format (skinned
position texcoord), for every material that has to use it, there will be compiled
shader variant with skinning injected - no more duplicating materials with extra
features, when we can just inject these features (middlewares) directly into
materials that use them!</p>
<hr />
<p>As you can see, all of this moves away burden of careful producing of all shader
code from user to the engine. With materials there is no more need for any
tedious, boilerplate-y and unnecessary <code>#ifdef</code>-ed shader code - we have reduced
the complexity of shader creation and management to bare minimum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-pipeline"><a class="header" href="#render-pipeline">Render Pipeline</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>HA renderer requires user to define render pipelines on game app setup phase.
Render pipelines describe how camera that uses given render pipeline, should
render world entities.</p>
<p>Let's take a look at typical renderer setup first:</p>
<pre><code class="language-rust ignore">HaRenderer::new(WebPlatformInterface::with_canvas_id(
    &quot;screen&quot;,
    WebContextOptions::default(),
)?)
.with_stage::&lt;RenderForwardStage&gt;(&quot;forward&quot;)
.with_stage::&lt;RenderGizmoStage&gt;(&quot;gizmos&quot;)
.with_stage::&lt;RenderUiStage&gt;(&quot;ui&quot;)
.with_pipeline(
    &quot;default&quot;,
    PipelineDescriptor::default()
        .render_target(&quot;main&quot;, RenderTargetDescriptor::Main)
        .stage(
            StageDescriptor::new(&quot;forward&quot;)
                .render_target(&quot;main&quot;)
                .domain(&quot;@material/domain/surface/flat&quot;)
                .clear_settings(ClearSettings {
                    color: Some(Rgba::gray(0.2)),
                    depth: false,
                    stencil: false,
                }),
        )
        .debug_stage(
            StageDescriptor::new(&quot;gizmos&quot;)
                .render_target(&quot;main&quot;)
                .domain(&quot;@material/domain/gizmo&quot;),
        )
        .stage(
            StageDescriptor::new(&quot;ui&quot;)
                .render_target(&quot;main&quot;)
                .domain(&quot;@material/domain/surface/flat&quot;),
        ),
)
</code></pre>
<p>From that code snippet we can tell than render pipelines contains:</p>
<ul>
<li>set of render targets used to render into.</li>
<li>set of render stages that tells how to render geometry to given render target.</li>
</ul>
<p>What is important here is that for render stages we are required to provide its
render target name for stage to know where to store all information it produces,
as well as domain graph name which is the shader backend for all shader frontends
(material graphs) used by entities in the world.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<h4 id="recording-to-render-queue"><a class="header" href="#recording-to-render-queue">Recording to Render Queue</a></h4>
<p>At first, renderer searches for new camera components, for each camera it creates its own instance of render pipeline that camera component points at.</p>
<p>Then all render stage systems goes through all cameras that contain render stages
with stage type given system provides, here is a brief snippet example:</p>
<pre><code class="language-rust ignore">pub fn ha_render_gizmo_stage_system(universe: &amp;mut Universe) {
<span class="boring">   type V = GizmoVertex;
</span><span class="boring">
</span>    let (
        world,
        mut renderer,
        lifecycle,
        mut gizmos,
        material_mapping,
        image_mapping,
        mut cache,
        ..,
    ) = universe.query_resources::&lt;HaRenderGizmoStageSystemResources&gt;();

<span class="boring">   if gizmos.factory.is_empty() {
</span><span class="boring">       return;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   let layout = match V::vertex_layout() {
</span><span class="boring">       Ok(layout) =&gt; layout,
</span><span class="boring">       Err(_) =&gt; return,
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   let mesh_id = match cache.mesh {
</span><span class="boring">       Some(mesh_id) =&gt; mesh_id,
</span><span class="boring">       None =&gt; {
</span><span class="boring">           let mut m = Mesh::new(layout.to_owned());
</span><span class="boring">           m.set_regenerate_bounds(false);
</span><span class="boring">           m.set_vertex_storage_all(BufferStorage::Dynamic);
</span><span class="boring">           m.set_index_storage(BufferStorage::Dynamic);
</span><span class="boring">           match renderer.add_mesh(m) {
</span><span class="boring">               Ok(mesh_id) =&gt; {
</span><span class="boring">                   cache.mesh = Some(mesh_id);
</span><span class="boring">                   mesh_id
</span><span class="boring">               }
</span><span class="boring">               Err(_) =&gt; return,
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   };
</span><span class="boring">   match renderer.mesh_mut(mesh_id) {
</span><span class="boring">       Some(mesh) =&gt; match gizmos.factory.factory() {
</span><span class="boring">           Ok(factory) =&gt; {
</span><span class="boring">               if factory.write_into(mesh).is_err() {
</span><span class="boring">                   return;
</span><span class="boring">               }
</span><span class="boring">           }
</span><span class="boring">           Err(_) =&gt; return,
</span><span class="boring">       },
</span><span class="boring">       None =&gt; return,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   gizmos
</span><span class="boring">       .material
</span><span class="boring">       .update_references(&amp;material_mapping, &amp;image_mapping);
</span><span class="boring">   let material_id = match gizmos.material.reference.id().copied() {
</span><span class="boring">       Some(material_id) =&gt; material_id,
</span><span class="boring">       None =&gt; return,
</span><span class="boring">   };
</span><span class="boring">   let time = vec4(
</span><span class="boring">       lifecycle.time_seconds(),
</span><span class="boring">       lifecycle.delta_time_seconds(),
</span><span class="boring">       lifecycle.time_seconds().fract(),
</span><span class="boring">       0.0,
</span><span class="boring">   );
</span><span class="boring">
</span>    for (_, (visibility, camera, transform)) in world
        .query::&lt;(Option&lt;&amp;HaVisibility&gt;, &amp;HaCamera, &amp;HaTransform)&gt;()
        .iter()
    {
        if !visibility.map(|v| v.0).unwrap_or(true) {
            continue;
        }
        let iter = match camera.record_to_pipeline_stage::&lt;RenderGizmoStage&gt;(&amp;renderer, transform) {
            Some(iter) =&gt; iter,
            None =&gt; continue,
        };
        for (info, render_queue) in iter {
            let mut render_queue = match render_queue.write() {
                Ok(render_queue) =&gt; render_queue,
                Err(_) =&gt; continue,
            };
            render_queue.clear();
            let mut recorder = render_queue.auto_recorder(None);
<span class="boring">
</span>            let _ = recorder.record(RenderCommand::ActivateMesh(mesh_id));
<span class="boring">           let signature = info.make_material_signature(&amp;layout);
</span>            let _ = recorder.record(RenderCommand::ActivateMaterial(
                material_id,
                signature.to_owned(),
            ));
<span class="boring">           let _ = recorder.record(RenderCommand::OverrideUniform(
</span><span class="boring">               MODEL_MATRIX_NAME.into(),
</span><span class="boring">               Mat4::identity().into(),
</span><span class="boring">           ));
</span><span class="boring">           let _ = recorder.record(RenderCommand::OverrideUniform(
</span><span class="boring">               VIEW_MATRIX_NAME.into(),
</span><span class="boring">               info.view_matrix.into(),
</span><span class="boring">           ));
</span>            let _ = recorder.record(RenderCommand::OverrideUniform(
                PROJECTION_MATRIX_NAME.into(),
                info.projection_matrix.into(),
            ));
<span class="boring">           let _ = recorder.record(RenderCommand::OverrideUniform(
</span><span class="boring">               TIME_NAME.into(),
</span><span class="boring">               time.into(),
</span><span class="boring">           ));
</span><span class="boring">           for (key, value) in &amp;gizmos.material.values {
</span><span class="boring">               let _ = recorder.record(RenderCommand::OverrideUniform(
</span><span class="boring">                   key.to_owned().into(),
</span><span class="boring">                   value.to_owned(),
</span><span class="boring">               ));
</span><span class="boring">           }
</span><span class="boring">           if let Some(draw_options) = &amp;gizmos.material.override_draw_options {
</span><span class="boring">               let _ = recorder.record(RenderCommand::ApplyDrawOptions(draw_options.to_owned()));
</span><span class="boring">           }
</span>            let _ = recorder.record(RenderCommand::DrawMesh(MeshDrawRange::All));
<span class="boring">           let _ = recorder.record(RenderCommand::ResetUniforms);
</span>            let _ = recorder.record(RenderCommand::SortingBarrier);
        }
    }
<span class="boring">
</span><span class="boring">   gizmos.factory.clear();
</span>}
</code></pre>
<p><em>You can toggle full code reveal to see what is actually happening there.</em></p>
<p>As you can see, when we get an iterator over requested render stages for cameras,
all we do next is to get access to render queue, create auto recorder (to ease
writing ordered render commands) and start recording commands. Although Gizmo
render system renders already batched gizmo geometry in other render systems, you
can get the idea that all what recording phase cares about is to just record
render commands into render queue of given camera render pipeline, it doesn't
really matter where we get data from, what matters is what gets into render
queue. We could also just iterate over world entities and record their render
commands to the queue - in matter of fact, this is how Render Forward Stage does
that, here we show Render Gizmo Stage for the sake of simplified explanation.</p>
<h4 id="execution-of-render-queues"><a class="header" href="#execution-of-render-queues">Execution of render queues</a></h4>
<p>After all render stage systems complete recording commands into queues, renderer
is now ready to go through all active render pipelines and execute their render
queues.</p>
<p>You can remember that when we were talking about recording to Render Queues, we
have been mentioning auto ordered recordings of commands - but what does that
means? Well, sometimes your render stage system might require its commands to be
ordered by for example some kind of depth value. For this case, to not require
user to collect entities to sort them and then record them in proper order, we
just encode order information in render command group index and enable optional
render queue sorting in stage descriptor. That way we do not break unspecified
order of entities iteration and just sort render commands itself. This obviously
has its own cost so it's just an optional step and you should definitely
benchmark to decide which of either render commands sorting or manual entity
sorting approach will benefit more your stage rendering.</p>
<p>Another thing worth mentioning about render queues is that they are only data
containers so you can for example create your own render queues separately from
what render pipeline provides, for example as a way of caching queues and reusing
them with multiple pipelines by flushing your custom render queue into one provided
by the render pipeline. Yet another use of render queues is to instead of recording
them in your application, you can send them via network socket to render it on
client application that will reflect your camera setup, but instead of recording
world itself, it will render what server sends - similar use case could be for
making both game and editor worlds embeded in one application host and game world
sending its recorded queues to editor world which then renders game view in its
rendering context.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more"><a class="header" href="#more">More...</a></h1>
<p>If you need an explanation of some Oxygengine related topic, consider creating
an issue on GitHub explaining what are you trying to achieve.</p>
<p>You can create new issue here: <a href="https://github.com/PsichiX/Oxygengine/issues/new">https://github.com/PsichiX/Oxygengine/issues/new</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
