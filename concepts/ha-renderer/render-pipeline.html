<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Render Pipeline - Oxygengine Essentials Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../cli/introduction.html"><strong aria-hidden="true">2.</strong> Oxygengine Ignite CLI tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../cli/update.html"><strong aria-hidden="true">2.1.</strong> Update engine version used in your game project</a></li><li class="chapter-item expanded "><a href="../../cli/faster-compilation-times.html"><strong aria-hidden="true">2.2.</strong> Speed up compilation times for new projects</a></li><li class="chapter-item expanded "><a href="../../cli/asset-pipeline.html"><strong aria-hidden="true">2.3.</strong> Asset pipeline and its tools</a></li><li class="chapter-item expanded "><a href="../../cli/new-project.html"><strong aria-hidden="true">2.4.</strong> Creating new project</a></li><li class="chapter-item expanded "><a href="../../cli/build-project.html"><strong aria-hidden="true">2.5.</strong> Building your project</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Concepts explained</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../concepts/ha-renderer/introduction.html"><strong aria-hidden="true">3.1.</strong> Hardware Accelerated rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../concepts/ha-renderer/render-pipeline.html" class="active"><strong aria-hidden="true">3.1.1.</strong> Render Pipeline</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.2.</strong> Camera</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.3.</strong> Render Target</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.4.</strong> Image</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.5.</strong> Virtual Image</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.6.</strong> Mesh</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.7.</strong> Virtual Mesh</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.8.</strong> Material</div></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Tutorials</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> RPG game using Overworld module</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> VN game using Visual Novel module</div></li></ol></li><li class="chapter-item expanded "><a href="../../more.html"><strong aria-hidden="true">5.</strong> More...</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Oxygengine Essentials Book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="render-pipeline"><a class="header" href="#render-pipeline">Render Pipeline</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>HA renderer requires user to define render pipelines on game app setup phase.
Render pipelines describe how camera that uses given render pipeline, should
render world entities.</p>
<p>Let's take a look at typical renderer setup first:</p>
<pre><code class="language-rust ignore">HaRenderer::new(WebPlatformInterface::with_canvas_id(
    &quot;screen&quot;,
    WebContextOptions::default(),
)?)
.with_stage::&lt;RenderForwardStage&gt;(&quot;forward&quot;)
.with_stage::&lt;RenderGizmoStage&gt;(&quot;gizmos&quot;)
.with_stage::&lt;RenderUiStage&gt;(&quot;ui&quot;)
.with_pipeline(
    &quot;default&quot;,
    PipelineDescriptor::default()
        .render_target(&quot;main&quot;, RenderTargetDescriptor::Main)
        .stage(
            StageDescriptor::new(&quot;forward&quot;)
                .render_target(&quot;main&quot;)
                .domain(&quot;@material/domain/surface/flat&quot;)
                .clear_settings(ClearSettings {
                    color: Some(Rgba::gray(0.2)),
                    depth: false,
                    stencil: false,
                }),
        )
        .stage(
            StageDescriptor::new(&quot;gizmos&quot;)
                .render_target(&quot;main&quot;)
                .domain(&quot;@material/domain/gizmo&quot;),
        )
        .stage(
            StageDescriptor::new(&quot;ui&quot;)
                .render_target(&quot;main&quot;)
                .domain(&quot;@material/domain/surface/flat&quot;),
        )
)
</code></pre>
<p>From that code snippet we can tell than render pipelines contains:</p>
<ul>
<li>set of render targets used to render into.</li>
<li>set of render stages that tells how to render geometry to given render target.</li>
</ul>
<p>What is important here is that for render stages we are required to provide its
render target name for stage to know where to store all information it produces,
as well as domain graph name which is the shader backend for all shader frontends
(material graphs) used by entities in the world.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<h4 id="recording-to-render-queue"><a class="header" href="#recording-to-render-queue">Recording to Render Queue</a></h4>
<p>At first, renderer searches for new camera components, for each camera it creates its own instance of render pipeline that camera component points at.</p>
<p>Then all render stage systems goes through all cameras that contain render stages
with stage type given system provides, here is a brief snippet example:</p>
<pre><code class="language-rust ignore">pub fn ha_render_gizmo_stage_system(universe: &amp;mut Universe) {
<span class="boring">   type V = GizmoVertex;
</span><span class="boring">
</span>    let (world, mut renderer, mut gizmos, material_mapping, image_mapping, mut cache, ..) =
        universe.query_resources::&lt;HaRenderGizmoStageSystemResources&gt;();

<span class="boring">   if gizmos.factory.is_empty() {
</span><span class="boring">       return;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   let layout = match V::vertex_layout() {
</span><span class="boring">       Ok(layout) =&gt; layout,
</span><span class="boring">       Err(_) =&gt; return,
</span><span class="boring">   };
</span><span class="boring">
</span><span class="boring">   let mesh_id = match cache.mesh {
</span><span class="boring">       Some(mesh_id) =&gt; mesh_id,
</span><span class="boring">       None =&gt; {
</span><span class="boring">           let mut m = Mesh::new(layout.to_owned());
</span><span class="boring">           m.set_vertex_storage_all(BufferStorage::Dynamic);
</span><span class="boring">           m.set_index_storage(BufferStorage::Dynamic);
</span><span class="boring">           match renderer.add_mesh(m) {
</span><span class="boring">               Ok(mesh_id) =&gt; {
</span><span class="boring">                   cache.mesh = Some(mesh_id);
</span><span class="boring">                   mesh_id
</span><span class="boring">               }
</span><span class="boring">               Err(_) =&gt; return,
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   };
</span><span class="boring">   match renderer.mesh_mut(mesh_id) {
</span><span class="boring">       Some(mesh) =&gt; match gizmos.factory.factory() {
</span><span class="boring">           Ok(factory) =&gt; {
</span><span class="boring">               if factory.write_into(mesh).is_err() {
</span><span class="boring">                   return;
</span><span class="boring">               }
</span><span class="boring">           }
</span><span class="boring">           Err(_) =&gt; return,
</span><span class="boring">       },
</span><span class="boring">       None =&gt; return,
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   gizmos
</span><span class="boring">       .material
</span><span class="boring">       .update_references(&amp;material_mapping, &amp;image_mapping);
</span><span class="boring">   let material_id = match gizmos.material.reference.id().copied() {
</span><span class="boring">       Some(material_id) =&gt; material_id,
</span><span class="boring">       None =&gt; return,
</span><span class="boring">   };
</span><span class="boring">
</span>    for (_, (visibility, camera, transform)) in world
        .query::&lt;(Option&lt;&amp;HaVisibility&gt;, &amp;HaCamera, &amp;HaTransform)&gt;()
        .iter()
    {
        if !visibility.map(|v| v.0).unwrap_or(true) {
            continue;
        }
        let iter = match camera.record_to_pipeline_stage::&lt;RenderGizmoStage&gt;(&amp;renderer, transform) {
            Some(iter) =&gt; iter,
            None =&gt; continue,
        };
        for (info, render_queue) in iter {
            let mut render_queue = match render_queue.write() {
                Ok(render_queue) =&gt; render_queue,
                Err(_) =&gt; continue,
            };
            render_queue.clear();
            let mut recorder = render_queue.auto_recorder(None);
<span class="boring">
</span><span class="boring">           let _ = recorder.record(RenderCommand::ActivateMesh(mesh_id));
</span><span class="boring">           let signature = info.make_material_signature(&amp;layout);
</span><span class="boring">           let _ = recorder.record(RenderCommand::ActivateMaterial {
</span><span class="boring">               id: material_id,
</span><span class="boring">               signature: signature.to_owned(),
</span><span class="boring">           });
</span><span class="boring">           let _ = recorder.record(RenderCommand::SubmitUniform {
</span><span class="boring">               signature: signature.to_owned(),
</span><span class="boring">               name: MODEL_MATRIX_NAME.into(),
</span><span class="boring">               value: Mat4::identity().into(),
</span><span class="boring">           });
</span><span class="boring">           let _ = recorder.record(RenderCommand::SubmitUniform {
</span><span class="boring">               signature: signature.to_owned(),
</span><span class="boring">               name: VIEW_MATRIX_NAME.into(),
</span><span class="boring">               value: info.view_matrix.into(),
</span><span class="boring">           });
</span><span class="boring">           let _ = recorder.record(RenderCommand::SubmitUniform {
</span><span class="boring">               signature: signature.to_owned(),
</span><span class="boring">               name: PROJECTION_MATRIX_NAME.into(),
</span><span class="boring">               value: info.projection_matrix.into(),
</span><span class="boring">           });
</span><span class="boring">           if let Some(draw_options) = &amp;gizmos.material.override_draw_options {
</span><span class="boring">               let _ = recorder.record(RenderCommand::ApplyDrawOptions(draw_options.to_owned()));
</span><span class="boring">           }
</span><span class="boring">           for (name, value) in &amp;gizmos.material.values {
</span><span class="boring">               let _ = recorder.record(RenderCommand::SubmitUniform {
</span><span class="boring">                   signature: signature.to_owned(),
</span><span class="boring">                   name: name.to_owned().into(),
</span><span class="boring">                   value: value.to_owned(),
</span><span class="boring">               });
</span><span class="boring">           }
</span><span class="boring">           let _ = recorder.record(RenderCommand::DrawMesh(MeshDrawRange::All));
</span><span class="boring">           let _ = recorder.record(RenderCommand::SortingBarrier);
</span>        }
    }
<span class="boring">
</span><span class="boring">   gizmos.factory.clear();
</span>}
</code></pre>
<p><em>You can toggle full code reveal to see what is actually happening there.</em></p>
<p>As you can see, when we get an iterator over requested render stages for cameras,
all we do next is to get access to render queue, create auto recorder (to ease
writing ordered render commands) and start recording commands. Although Gizmo
render system renders already batched gizmo geometry in other render systems, you
can get the idea that all what recording phase cares about is to just record
render commands into render queue of given camera render pipeline, it doesn't
really matter where we get data from, what matters is what gets into render
queue. We could also just iterate over world entities and record their render
commands to the queue - in matter of fact, this is how Render Forward Stage does
that, here we show Render Gizmo Stage for the sake of simplified explanation.</p>
<h4 id="execution-of-render-queues"><a class="header" href="#execution-of-render-queues">Execution of render queues</a></h4>
<p>After all render stage systems complete recording commands into queues, renderer
is now ready to go through all active render pipelines and execute their render
queues.</p>
<p>You can remember that when we were talking about recording to Render Queues, we
have been mentioning auto ordered recordings of commands - but what does that
means? Well, sometimes your render stage system might require its commands to be
ordered by for example some kind of depth value. For this case, to not require
user to collect entities to sort them and then record them in proper order, we
just encode order information in render command group index and enable optional
render queue sorting in stage descriptor. That way we do not break unspecified
order of entities iteration and just sort render commands itself. This obviously
has its own cost so it's just an optional step and you should definitely
benchmark to decide which of either render commands sorting or manual entity
sorting approach will benefit more your stage rendering.</p>
<p>Another thing worth mentioning about render queues is that they are only data containers so you can for example create your own render queues separately from what render pipeline provides, for example as a way of caching queues and reusing them with multiple pipelines by flushing your custom render queue into one provided by the render pipeline. Yet another use of render queues is to instead of recording them in your application, you can send them via network socket to render it on client application that will reflect your camera setup, but instead of recording world itself, it will render what server sends - similar use case could be for making both game and editor worlds embeded in one application host and game world sending its recorded queues to editor world which then renders game view in its rendering context.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../concepts/ha-renderer/introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../more.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../concepts/ha-renderer/introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../more.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
